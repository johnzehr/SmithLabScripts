import pyvisa, matplotlib.pyplot as plt, numpy as np
import datetime
from numpy.fft import fft, fftshift
import matplotlib.pyplot as plt
from scipy import signal


rm = pyvisa.ResourceManager()
rm.list_resources()
inst = rm.open_resource('USB0::0x0AAD::0x00C8::102457::0::INSTR') # fsw
smw =  rm.open_resource('USB0::0x0AAD::0x0092::109917::0::INSTR') # smw200a
smw.write(":SOURce1:FREQuency:CW 10e9")
smw.write(":SOURce1:POWer:POWer -10")
smw.write(':SOURce1:BB:ARBitrary:WAVeform:SELect "/var/user/waves200e62022-04-19"')
smw.write(':SOURce1:BB:ARBitrary:STATe 1')
inst.write(':SENS:FREQ:CENT 10e9')
inst.query('*OPC?')

def write_to(data):
    with open('meas.txt', 'w') as f:
        f.write(str(data))
#def read_from():
    

def iq_trace():
    inst.query('*OPC?')
    inst.write(":INIT:IMM;*WAI")
    inst.write('TRAC:IQ:DATA:FORM IQP')
    # smw.write(':SOURce1:BB:DM:STATe 1')
    smw.write(':SOURce1:BB:ARBitrary:TRIGger:EXECute')
    data = inst.query_ascii_values("TRAC:IQ:DATA:MEM?")
    data1 = data[::2][0:2000]
    data2 = data[1::2]
    time = float(inst.query('SENS:SWE:TIME?'))
    points = float(inst.query('TRAC:IQ:RLEN?'))
    xval = np.arange(0, time,(time/points))
 
    plt.figure(0)
    plt.title("Real Values")
    plt.xlabel("Seconds")
    plt.ylabel("mV")
    ax = plt.gca()
    plt.plot(xval, data1, color ='red')
     
    plt.figure(1)
    plt.title("Imaginary Values")
    plt.xlabel("Seconds")
    plt.ylabel("mV")
    ax2 = plt.gca()
    plt.plot(xval, data2)
    write_to(data)
    return data

def matched_filter(taup, b, rrec, winid, data_arr):
#def matched_filter(nscat,taup, b, rrec, scat_range,winid, data_arr,noise_amplitude)
    eps = 1.0e-16

    # speed of light
    c = 3.e8

    # number of samples
    n=(int)(np.fix(5*taup*b))
    replica = n*[0.0]
    
    
    # calculate sampling interval and create replica signal
    # t = np.linspace(-1 * taup / 2.0, taup / 2.0, n)
    # replica = np.exp(1j * np.pi * (b / taup) * (t ** 2))
    
    #--------------------------------------------------------------------------------------#
    num_samp = 3000
    clock = 1000e6
    delta_t = 1/(clock)
    T = num_samp * delta_t
    t = np.arange(0, T, delta_t)
    
    fstart=0
    fstop = 200e6
    chirp_rate = (fstop-fstart)/T
    fsig=2*np.pi*(((chirp_rate/2)*(t**2))+(fstart*t))

    fsweep= np.linspace(fstart, fstop, num_samp)
    signal = np.exp((1j*fsig))
        
    replica = signal # transmitted signal
                     # transmitted signal should be the signal generated by smw200a
    #--------------------------------------------------------------------------------------#
    
    
    # plot replica signal in time domain
    plt.figure(1)
    plt.subplot(2, 1, 1);
    plt.plot(t, np.real(replica))
    plt.ylabel('Real (part) of replica')
    plt.xlabel('time in seconds')
    plt.grid()
    plt.show()
    
    n = np.size(replica)
    # print(n)
    
    
    # determine proper window / weighing function
    if winid==0:
        win=n*[1]
        win = [[1.0]*n]
    elif winid==1:
        win = np.hamming(n)
    elif winid ==2:
        win = np.kaiser(n, np.pi)
    elif winid ==3:
        win = signal.chebwin(n, 60)

    
    # plot replica signal in frequency domain
    # sampling_interval = taup / n
    # freqlimit = .5 / sampling_interval
    # freq = np.linspace(-freqlimit, freqlimit, n)

    # plt.plot(freq, fftshift(abs(fft(replica))))
    # plt.ylabel('Spectrum of replica')
    # plt.xlabel('Frequency in Hz')
    # plt.grid()
    # plt.show()

    # correlate signals
    out = np.correlate(replica, data_arr, "full")
    out = out / n

    # plot output vs distance
    s = taup * c / 2
    Npoints = (int)(np.ceil(rrec * n / s))
    dist = np.linspace(0, rrec, Npoints)
    delr = c / 2 / b
    #print(delr)
    
    #dist = np.linspace(0, rrec, np.size(out)) # temporary
    # print(np.size(replica))
    # print(np.size(data_arr))
    # print(np.size(dist))
    # print(np.size(out))
    # print(np.size(out[n-1: n+Npoints-1]))
    
    plt.figure(2)
    plt.subplot(2, 1, 1)
    # plt.plot(np.log(np.abs(out)), 'k')
    # plt.plot(dist, np.abs(out), 'k')
    # plt.plot(np.abs(out), 'k')
    # plt.plot(dist, np.log(np.abs(out)), 'k')
    plt.plot(dist, np.abs(out[n-1: n+Npoints-1]), 'k')
    plt.xlabel('Target relative position in meters')
    plt.ylabel('Compressed echo')
    plt.grid()
    plt.show()
    


#matched_filter(3e-6, 200e6, 1, 0, info)


#matched_filter(3e-6, 200e6, 1, 0, info)
# matched_filter(3e-6, 0.2e9,10,0,info)
# matched_filter(.05, 1e9,10,0,info)
# matched_filter(taup, b, rrec, winid, data_arr)
# matched_filter(nscat,taup,b,rrec,scat_range,scat_rcs,winid,noise_amplitude)




'''def iq_trace():
    inst.write(":INIT:IMM;*WAI")
    inst.write('TRAC:IQ:DATA:FORM IQP')
    smw.write(':SOURce1:BB:ARBitrary:TRIGger:EXECute')
    data = inst.query_ascii_values("TRAC:IQ:DATA:MEM?")
    data1 = data[::2]
    data2 = data[1::2]
    time = float(inst.query('SENS:SWE:TIME?'))
    points = float(inst.query('TRAC:IQ:RLEN?'))
    xval = np.arange(0, time,(time/points))
    
    plt.figure(0)
    plt.title("Real Values")
    plt.xlabel("Seconds")
    plt.ylabel("mV")
    ax = plt.gca()
    plt.plot(xval, data1, color ='red')
    
    plt.figure(1)
    plt.title("Imaginary Values")
    plt.xlabel("Seconds")
    plt.ylabel("mV")
    ax2 = plt.gca()
    plt.plot(xval, data2)

iq_trace()'''