import pyvisa, matplotlib.pyplot as plt, numpy as np
from numpy.fft import fft, fftshift
import matplotlib.pyplot as plt
from scipy import signal
from datetime import datetime as dt

import dill as pickle


def save_pickle(dictionary, filename):
    f = open(filename, "wb")
    pickle.dump(dictionary, f)
    f.close()


def load_pickle(filename):
    f = open(filename, "rb")
    data = pickle.load(f)
    f.close()
    return data



#waveFilePath = 'C:/Users/smithlab/Downloads/waves/wave_11.obj'
#exportFilePath = 'recodedData'+now.strftime('%Y-%m-%d-(%H-%M-%S)')+'.obj'

waveFilePath = "C:/Users/smithlab/Downloads/waves/wave_11.obj"
# exportFilePath= 'C:/Users/smithlab/Downloads/waves/recodedData2022-11-17-(11-31-34).obj'
#exportFilePath= 'C:/Users/smithlab/Downloads/waves/recodedData2022-11-27-(18-09-34).obj'


def connect(waveFilePath, exportFilePath):
    datao=load_pickle(waveFilePath)
    cent = 10 + (abs(round(((datao['fstop']/(2*np.pi) - datao['fstart']/(2*np.pi))/2),4))/10**9)
    global rm
    global inst
    global smw
    rm = pyvisa.ResourceManager()
    rm.list_resources()
    inst = rm.open_resource('USB0::0x0AAD::0x00C8::102457::0::INSTR') # fsw
    smw =  rm.open_resource('USB0::0x0AAD::0x0092::109917::0::INSTR') # smw200a
    
    now = dt.now()
    
    smw.write(":SOURce1:FREQuency:CW 10e9")
    smw.write(":SOURce1:POWer:POWer -10")
    inst.write(':SENS:FREQ:CENT ' + str(cent) + 'e9')
    inst.write(':TRAC:IQ:SRAT '+str(datao['clock']))
    inst.write(':SENS:SWE:TIME ' + str(datao['numberSamples']/datao['clock']))
    
    
    
def write_to(data):
    with open('meas.txt', 'w') as f:
        f.write(str(data))
#def read_from():
    
def trigger():
    smw.write(':SOURce1:BB:ARBitrary:TRIGger:EXECute')
    
def iq_trace(waveFilePath, exportFilePath, note, plot=None):
    datao=load_pickle(waveFilePath)
    data = inst.query_ascii_values("TRAC:IQ:DATA:MEM?")
#    objFile = open("MetalSheet1m", "wb")
 #   pick.dump(data, objFile)
    # print(pick.dump(data))
  #  objFile.close()
    datai = data[:int(len(data)/2)]
    dataq = data[int(len(data)/2):]
    data_full = np.add(datai, np.multiply(dataq, 1j))
    time = float(inst.query('SENS:SWE:TIME?'))
    points = float(inst.query('TRAC:IQ:RLEN?'))
    xval = np.arange(0, time,(time/points))
    
    if plot is not None:
        plt.figure(0)
        plt.title("Real Values")
        plt.xlabel("Seconds")
        plt.ylabel("mV")
        ax = plt.gca()
        plt.plot(xval, datai, color ='red')
     #   
        plt.figure(1)
        plt.title("Imaginary Values")
        plt.xlabel("Seconds")
        plt.ylabel("mV")
        ax2 = plt.gca()
        plt.plot(xval, dataq)
        # write_to(data)
        
        plt.figure(2)
        plt.title("Combined IQ Values")
        plt.xlabel("Seconds")
        plt.ylabel("mV")
        ax2 = plt.gca()
        plt.plot(xval, np.abs(data_full), color = 'orange')
    
    inst.query('*OPC?')
    taup = datao['numberSamples']/datao['clock']
    b = int(abs(round(datao['fstop']-datao['fstart']/(4*np.pi),3)))
    
    #matched_filter(taup, b, rrec, winid, data)
    exportDict = {"description": note, "wave gen data":datao , "recorded data": data_full , "time": time, "points" : points, "background" : datao['originalPulse']}
    save_pickle(exportDict,exportFilePath)

    return data
    


# backgroundFile is file with background data. expFile contains the experimental data.
# this method adds a field to the experimental file that contains the background information
def add_background(backgroundFile,expFile):
    backGroundDict = load_pickle(backgroundFile)
    backgroundSig = backGroundDict['recorded data']
    expDict = load_pickle(expFile)
    expDict["background"] = backgroundSig
    save_pickle(expDict,expFile)

# Matched filering method that takes in pickle file generated by iq trace.
# backgrounded is boolean that indicates whether there is background signal in dictionary
# the background data can be added using add_background()
# measFilePath takes in file name to store post-processed measurements
def matched_filter(waveFilePath,measFilePath,backgrounded=False):
    # waveDataFile = open(waveFilePath,"rb")
    # waveDataFileDict = dill.load(waveDataFile)
    # waveDataFile.close()
    
    waveDataFileDict = load_pickle(waveFilePath)
    print(waveDataFileDict)
    
    eps = 1.0e-16
    originalPulseData = waveDataFileDict['originalPulse']
    # speed of light
    c = 3.e8
    # hardcode the distance we are imaging over
    rrec = 10
    # print(taup)
    # number of samples
    #n = waveDataFileDict['numberSamples']    
    
    num_samp = waveDataFileDict['numberSamples']
    clock = waveDataFileDict['clock']
    taup = num_samp/clock

    delta_t = 1 / (clock)
    T = num_samp * delta_t
    t = np.arange(0, T, delta_t)

    fstart = -1*waveDataFileDict['fstart']
    fstop = -1*waveDataFileDict['fstop']
    chirp_rate = (fstop - fstart) / T
    signal = waveDataFileDict['originalPulse']

    replica = signal  # transmitted signal
    
    # plt.plot(replica)
    # transmitted signal should be the signal generated by smw200a
    # --------------------------------------------------------------------------------------#

    # plot replica signal in time domain
    # plt.figure(1)
    # plt.subplot(2, 1, 1);
    # plt.plot(t, np.real(replica))
    # plt.ylabel('Real (part) of replica')
    # plt.xlabel('time in seconds')
    # plt.grid()
    # plt.show()'
    
    n = 200000
    duration = (200000*1.0)/10e10
    
    n = num_samp
    duration = (n*1.0)/10e10
    timeVect = np.linspace(0,duration,num_samp)
    beta = fstart
    alpha = (fstop-fstart)/(2*duration)
    i_data = np.imag(np.exp(1j*beta*timeVect+1j*alpha*np.power(timeVect,2)))
    q_data = np.real(np.exp(1j*beta*timeVect+1j*alpha*np.power(timeVect,2)))
    complexData = i_data + q_data
    
    timeVect= np.linspace(0,n*(1/clock),n)
    carrierSig = np.cos(timeVect*np.pi*2*10e10)
    replica = np.multiply(carrierSig,replica)
    
    
    
    # print(n)

    # determine proper window / weighing function
    # winid = 0
    # if winid == 0:
    #     win = n * [1]
    #     win = [[1.0] * n]
    # elif winid == 1:
    #     win = np.hamming(n)
    # elif winid == 2:
    #     win = np.kaiser(n, np.pi)
    # elif winid == 3:
    #     win = signal.chebwin(n, 60)
        
    # measDataFile = open(measFilePath,"rb")
    # measDataFileDict = dill.load(measDataFile)
    # measDataFile.close()
    
    measDataFileDict = load_pickle(measFilePath)

    data_arr = measDataFileDict['recorded data']
    # print(data_arr)
    # plt.plot(data_arr)
#   subtract background signal if it exists in dictionary
    if(backgrounded and measDataFileDict['background'] != []):
        data_arr = np.subtract(data_arr,waveDataFileDict['background'])
    # # correlate signals
    # print(np.shape(replica))
    # print(np.shape(data_arr))
    frequencySpace = np.linspace(0,clock,6000)
    plt.plot(np.abs(fft(replica)))
    plt.plot(np.abs(fft(data_arr)))
    plt.legend(['Tx', 'Rx'])
    plt.show()
    
    out = np.correlate(replica, data_arr, "full")
    out = out / n

    # plot output vs distance
    s = taup * c / 2
    Npoints = (int)(np.ceil(rrec * n / s))
    # print(Npoints)
    dist = np.linspace(0, rrec, Npoints)
    # print(dist)
    #delr = c / 2 / b
    # print(delr)

    plt.figure(2)
    plt.subplot(2, 1, 1)

    plt.plot(dist, np.abs(out[n - 1: n + Npoints - 1]), 'k')
    plt.xlabel('Target relative position in meters')
    plt.ylabel('Compressed echo')
    plt.grid()
    plt.show()
    
    # measDataFileDict = load_pickle(measFilePath)
    # print(measDataFileDict)
    
    # measDataFile = open(measFilePath, 'ab')
    # measFileDict = dill.load(measDataFile)
    # measFileDict.append({"rrec":rrec, "correlation data": out})
    # dill.dump(measFileDict, waveDataFile)
    # waveDataFile.close()


#iq_trace()

def old_matched_filter(taup, b, rrec, winid, data_arr):
#def matched_filter(nscat,taup, b, rrec, scat_range,winid, data_arr,noise_amplitude)
    eps = 1.0e-16

    # speed of light
    c = 3.e8

    # number of samples
    n=(int)(np.fix(5*taup*b))
    replica = n*[0.0]
    
    
    # calculate sampling interval and create replica signal
    # t = np.linspace(-1 * taup / 2.0, taup / 2.0, n)
    # replica = np.exp(1j * np.pi * (b / taup) * (t ** 2))
    
    #--------------------------------------------------------------------------------------#
    #num_samp = 3000
    #clock = 1000e6
    num_samp = 20000
    clock= 50000
    delta_t = 1/(clock)
    T = num_samp * delta_t
    t = np.arange(0, T, delta_t)
    
    fstart=0
    fstop = 200e6
    chirp_rate = (fstop-fstart)/T
    fsig=2*np.pi*(((chirp_rate/2)*(t**2))+(fstart*t))

    fsweep= np.linspace(fstart, fstop, num_samp)
    signal = np.exp((1j*fsig))
        
    replica = signal # transmitted signal
                     # transmitted signal should be the signal generated by smw200a
    #--------------------------------------------------------------------------------------#
    
    
    # plot replica signal in time domain
    plt.figure(1)
    plt.subplot(2, 1, 1);
    plt.plot(t, np.real(replica))
    plt.ylabel('Real (part) of replica')
    plt.xlabel('time in seconds')
    plt.grid()
    plt.show()
    
    n = np.size(replica)
    # print(n)
    
    
    # determine proper window / weighing function
    if winid==0:
        win=n*[1]
        win = [[1.0]*n]
    elif winid==1:
        win = np.hamming(n)
    elif winid ==2:
        win = np.kaiser(n, np.pi)
    elif winid ==3:
        win = signal.chebwin(n, 60)

    
    # plot replica signal in frequency domain
    # sampling_interval = taup / n
    # freqlimit = .5 / sampling_interval
    # freq = np.linspace(-freqlimit, freqlimit, n)

    # plt.plot(freq, fftshift(abs(fft(replica))))
    # plt.ylabel('Spectrum of replica')
    # plt.xlabel('Frequency in Hz')
    # plt.grid()
    # plt.show()

    # correlate signals
    out = np.correlate(replica, data_arr, "full")
    out = out / n

    # plot output vs distance
    s = taup * c / 2
    Npoints = (int)(np.ceil(rrec * n / s))
    dist = np.linspace(0, rrec, Npoints)
    delr = c / 2 / b
    #print(delr)
    
    #dist = np.linspace(0, rrec, np.size(out)) # temporary
    # print(np.size(replica))
    # print(np.size(data_arr))
    # print(np.size(dist))
    # print(np.size(out))
    # print(np.size(out[n-1: n+Npoints-1]))
    
    plt.figure(2)
    plt.subplot(2, 1, 1)
    # plt.plot(np.log(np.abs(out)), 'k')
    # plt.plot(dist, np.abs(out), 'k')
    # plt.plot(np.abs(out), 'k')
    # plt.plot(dist, np.log(np.abs(out)), 'k')
    plt.plot(dist, np.abs(out[n-1: n+Npoints-1]), 'k')
    plt.xlabel('Target relative position in meters')
    plt.ylabel('Compressed echo')
    plt.grid()
    plt.show()
#
#connect()
#trigger()
#iq_trace()
#matched_filter(waveFilePath, exportFilePath, 0)